# 	This code has been developed for the Raspberry Pi Pico W connected to a Pimoroni 16x7 LED matrix.
#	
#	Uses example from the documentation as a basis for DMA chaining:
# 		https://docs.micropython.org/en/latest/library/rp2.DMA.html
# 	Uses the pio from here (changed to pythonic version and slightly modified):
#       https://github.com/pimoroni/pimoroni-pico/blob/main/libraries/pico_unicorn/pico_unicorn.pio


from rp2 import DMA
from uctypes import addressof
from array import array
import time
import pio
from machine import Pin
import time
from machine import mem32

TXF0_addr = const(0x50200010)   # address of TX FIFO register for State Machine 0
RXF0_addr = const(0x50200020)   # address of RX FIFO register for State Machine 0

TXF1_addr = const(0x50200014)   # address of TX FIFO register for State Machine 0
RXF1_addr = const(0x50200024)   # address of RX FIFO register for State Machine 0


def transfer_data(input_array, buf):
    """
        transfer_data transfers data to either the output buf OR a pio defined within transfer_data,
        depending on the test value:
         - test == True: transfer_data transfers to buf and displays the image using StateMachine.put().
            this test is to separate the two functionalities - to show that the DMA chain is working,
            and to show that the PIO is working separately as intended.
         - test == False: transfer_data transfers to the PIO TX FIFO register. 
        
        Both cases use DMA chaining:
         - gather_dma chains to the buffer_dma,
         - buffer_dma *chains to itself*, meaning that chaining is disabled for this channel.
         
        Specifically in the case where test=False, buffer_dma generates an interrupt at end of transfer.
        Within the interrupt generated by the buffer_dma, the gather_dma is re-configured and retriggered.
        The reason for not chaining back the buffer_dma back to the gather_dma, is that we want a time during
        which gather_dma is not running while we reconfigure it. I've found that reconfiguring a dma while
        it was running led to memory errors (MemoryError: ). So a brief pause is necessary.
        
        gather_dma, as per the example in the micropython documentation (see link above), directly populates
        the buffer_dma registers with:
         - the number of transfers (COUNT register)
         - the address of the start of the input_array array.
        
        Then, buffer_dma is triggered/turned to active by gather_dma once gather_dma writes to buffer_dma
        registers, and buffer_dma either dumps that data in the output buffer (if test==True) or writes
        data to the PIO TX FIFO.
        

    """
      
    #--------------------------------------------- DMA INIT ---------------------------------------------#
    # We use two DMA channels. The first sends lengths and source addresses from the gather
    # list to the registers of the second. The second copies the data itself.
    gather_dma = DMA()
    buffer_dma = DMA()
    restart_dma = DMA()
    #----------------------------------------------------------------------------------------------------#
    
    #--------------------------------------------- GATHER LIST ------------------------------------------#
    # Pack up length/address pair of input_array to be sent to the buffer_dma registers.
    # This only works for a single input_array = array("L", [])
    gather_list = array("L")
    
    for row in input_array:
        gather_list.append(addressof(buf))
        gather_list.append(len(row))       # CH0_AL3_TRANS_COUNT
        gather_list.append(addressof(row)) # CH0_AL3_READ_ADDR_TRIG
        #gather_list.append(0)
        
    
    gather_list_addr_start = addressof(gather_list) # for gather_dma range check
    gather_list_addr_end = gather_list_addr_start + len(gather_list)*4
    
    print(gather_list_addr_start, gather_list_addr_end)
    print(gather_list)
    
    #----------------------------------------------------------------------------------------------------#
    
  
    
    #--------------------------------------------- GATHER DMA -------------------------------------------#
    # When writing to the registers of the second DMA channel, we need to wrap the
    # write address on an 8-byte (1<<3 bytes) boundary. We write to the ``TRANS_COUNT``
    # and ``READ_ADD_TRIG`` registers in the last register alias (registers 14 and 15
    # respectively).
    gather_ctrl = gather_dma.pack_ctrl(
        enable=True,
        high_pri=False,
        size=2,
        inc_read=True,
        inc_write=True,
        ring_size=4,
        ring_sel=True,
        treq_sel=63,
        irq_quiet=False,
        bswap=False,
        sniff_en=False,
        chain_to=buffer_dma.channel
    )   
    
    gather_dma.config(
        read=addressof(gather_list), write=buffer_dma.registers[13:16],
        count=3, ctrl=gather_ctrl, trigger=False
    )
    
    def gather_dma_irq(gather_dma):
        print("gather_dma irq")
    
    gather_dma.irq(handler=gather_dma_irq, hard=False)
    
    #----------------------------------------------------------------------------------------------------#
    
       
        
    #--------------------------------------------- BUFFER DMA -------------------------------------------#
    
    # for writing to an output buffer only
    buffer_ctrl = buffer_dma.pack_ctrl(
        enable=True,
        high_pri=False,
        size=2,
        inc_read=True,   
        inc_write=True,             # inc_write required for writing to output buffer.
        ring_size=0,                
        ring_sel=False,
        treq_sel=63,      
        irq_quiet=False,             # no need for restarting gather_dma using irq in the test, so this is set to quiet.
        bswap=False,
        sniff_en=False,
        chain_to=restart_dma.channel # this could be chained to self and then trigger interrupt, but I want to save on interrupts.
    )
        
        
    # The read and count values will be set by the other DMA channel.
    buffer_dma.config(write=addressof(buf), ctrl=buffer_ctrl, trigger=False)
        
        
    def buffer_dma_irq_handler(buffer_dma):
        print("buffer_dma irq")
            

    buffer_dma.irq(handler=buffer_dma_irq_handler, hard=False)
    #----------------------------------------------------------------------------------------------------#
 
    #--------------------------------------------- RESTART DMA -------------------------------------------#
    # for writing to an output buffer only
    restart_ctrl = restart_dma.pack_ctrl(
        enable=True,
        high_pri=False,
        size=2,
        inc_read=True,   
        inc_write=False,             # inc_write required for writing to output buffer.
        ring_size=0,
        ring_sel=False,
        treq_sel=1,                  # = DREQ_PIO0_TX0, 1 = DREQ_PIO0_TX1
        irq_quiet=False,             # no need for restarting gather_dma using irq in the test, so this is set to quiet.
        bswap=False,
        sniff_en=False,
        chain_to=restart_dma.channel 
    )
    
    def restart_dma_irq(restart_dma):
        print("restart_dma irq")
        
    # The read and count values will be set by the other DMA channel.
    restart_dma.config(write=TXF1_addr, ctrl=restart_ctrl, count=1, trigger=False)
    
    restart_dma.irq(handler=restart_dma_irq, hard=False)
    #----------------------------------------------------------------------------------------------------#
    
    #-------------------------------------------- PIO CHOKE SETUP ------------------------------------------#
    # Used for pacing the gather_dma.
    # The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk). This equation is evaluated every
    # sys_clk cycles and therefore can only generate TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less.
    # From section 2.15.3, sys_clk, or clk_sys is 125MHz.
    # this means the maximum division we an get is 125MHz / (1/2^16) = 1.9kHz. This is not low enough,
    # so we need to use a PIO to choke the DMA even further.
    @rp2.asm_pio(fifo_join = rp2.PIO.JOIN_TX, autopull=True, pull_thresh=32, autopush=True, push_thresh=32)
    def trigger_dma_1hz():
        # we are limited by delay number and what we can set x to.
        # Cycles: 1 + 7 + 32 * (29 + 1 + 1) = 1000        
        # repeat twice with minimum freq=2000
        # then you get 1Hz.
        wrap_target()
        
        pull(ifempty)               # pull data. 
        out(null, 32)               # discard input 
        
        set(x, 31)                  [6]
        label("delay_1")
        nop()                       [29] # [29] means repeat 29 times.
        jmp(x_dec, "delay_1")
        
        set(x, 31)                  [6]
        label("delay_2")
        nop()                       [29] # [29] means repeat 29 times.
        jmp(x_dec, "delay_2")

        irq(rel(0))
        
        wrap()
        
    def sm_irq(sm):
        print("sm_irq", buf)
        # if we've reached the end of the whole list of frames, restart from beginning.
        if gather_dma.read >= gather_list_addr_end:
            gather_dma.config(read=addressof(gather_list), write=buffer_dma.registers[13:16], trigger=True )
        else:
            # note it is necessary to set write as the buffer_dma registers again. 
            gather_dma.config(write=buffer_dma.registers[13:16], trigger=True)

    
    rp2.PIO(0).remove_program()
    sm = rp2.StateMachine(1, trigger_dma_1hz, freq=2000)
    sm.irq(handler=sm_irq, hard=False)
    
    
    #----------------------------------------------------------------------------------------------------#


    #--------------------------------------------- ACTIVATION -------------------------------------------#    
    
    # activate state machine
    sm.active(1)
    
    # activate gather_dma. Do not activate buffer_dma, as gather_dma will trigger it once it properly sets
    # buffer_dma up.
    gather_dma.active(1)
    
    print("DMAs commenced.")
    
    return gather_dma, buffer_dma, restart_dma, sm

    #----------------------------------------------------------------------------------------------------#


#### MAIN ####


input_red = array("L", [0, 0,  0,  0, 0,  0, 0,  0, 253, 0, 4095,
                        0, 34, 0,  0, 34, 0, 34, 0, 251, 0, 4095,
                        0, 34, 0,  0, 34, 0, 34, 0, 247, 0, 4095,
                        0, 34, 34, 34,34, 0, 34, 0, 239, 0, 4095,
                        0, 34, 0,  0, 34, 0, 34, 0, 223, 0, 4095,
                        0, 34, 0,  0, 34, 0, 34, 0, 191, 0, 4095,
                        0, 0,  0,  0, 0,  0, 0,  0, 127, 0, 4095])

input_blue = array("L", [0, 0,  0,  0, 0,  0, 0,  0, 253, 0, 4095,
                        0, 68, 0,  0, 68, 0, 68, 0, 251, 0, 4095,
                        0, 68, 0,  0, 68, 0, 68, 0, 247, 0, 4095,
                        0, 68, 68, 68,68, 0, 68, 0, 239, 0, 4095,
                        0, 68, 0,  0, 68, 0, 68, 0, 223, 0, 4095,
                        0, 68, 0,  0, 68, 0, 68, 0, 191, 0, 4095,
                        0, 0,  0,  0, 0,  0, 0,  0, 127, 0, 4095])

animation = [input_red, input_blue]
                        

output = array('L', [])
for i in range(0, 154):
    output.append(0)


print("Output buffer before DMAs set in motion: ", output)
gather_dma, buffer_dma, restart_dma, sm = transfer_data(animation, output)
while True:
    time.sleep(4)
    print("####### GATHER DMA REGISTERS #######")
    for register in gather_dma.registers:
        print(register)
    print("####### BUFFER DMA REGISTERS #######")
    for register in buffer_dma.registers:
        print(register)
    





